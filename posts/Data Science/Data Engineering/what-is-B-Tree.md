---
title: "B-Tree에 대한 정리"
date: "2025-08-14"
excerpt: "B-Tree가 뭐고, 어떤 원리로 동작하는지 자세히 정리"
category: "Data Engineering"
tags: ["DB", "SQL", "B-Tree"]
---

참고자료
- 1 : [MySQL - B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/286)

인덱스를 저장하는 방식

> 인덱스를 저장하는 방식(또는 알고리즘)에 따라 B-Tree 인덱스, Hash 인덱스, Fractal 인덱스 등으로 나눌 수 있습니다. 
> 일반적으로 B-Tree 구조가 사용되기 때문에 B-Tree 인덱스를 통해 인덱스의 동작 방식에 대해 살펴보도록 하겠습니다. (참고 1)

## 1. B-Tree 구조

<figure>
<img src="./images/B-Tree-Structure.png" alt="B-Tree Structure" />
<figcaption>그림1. B-Tree Structure</figcaption>
</figure>

B-Tree구조는 이진트리를 확장하여 N개의 자식을 가질 수 있도록 고안된 것.

## 2. Page or Block

Page or Block : 디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위

> 인덱스의 저장 방식을 이해하기 위해서는 페이지(또는 블럭)에 대해 알아야 한다. 
> 페이지란 디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위이다. 일반적인 인덱스를 포함해 PK(클러스터 인덱스)와 테이블 등은 모두 페이지 단위로 관리된다. 
> 따라서 만약 쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 블록을 읽어야 하는 것이다 (참고 1)

**기본 정의**
- 페이지/블록: 디스크와 메모리 간 데이터 전송의 최소 단위
- 크기: 일반적으로 4KB, 8KB, 16KB 등으로 표준화
- 목적: I/O 효율성과 메모리 관리를 위한 단위화

**왜 페이지 단위로 관리하는가?**
1. 디스크 I/O 효율성
   - 디스크 특성: 디스크는 순차 접근에 최적화되어 있음
   - Seek Time: 디스크 헤드가 특정 위치로 이동하는 시간
   - Transfer Time: 실제 데이터를 읽고 쓰는 시간
   - 페이지 단위: 한 번의 디스크 접근으로 여러 레코드 처리
2. 메모리 관리 효율성
   - 버퍼 풀: 자주 사용되는 페이지를 메모리에 유지
   - LRU 알고리즘: 최근 사용된 페이지를 메모리에 유지
   - 페이지 교체: 메모리 부족 시 사용 빈도가 낮은 페이지 제거



## 3. 버퍼풀(Buffer Pool)과 메모리 캐싱 시스템

**정의와 목적**
- 버퍼풀: 데이터베이스가 자주 사용하는 페이지를 메모리에 유지하는 캐시 영역
- 크기: 일반적으로 전체 메모리의 70-80% 할당
- 목적: 디스크 I/O 최소화로 성능 향상

**페이지 로딩 과정**
1. 쿼리 실행 요청
2. 버퍼풀에서 페이지 검색
3. 페이지가 없으면 (Cache Miss):
   - 디스크에서 페이지 로드
   - 버퍼풀에 저장
   - LRU 리스트에 추가
4. 페이지가 있으면 (Cache Hit):
   - 메모리에서 직접 데이터 접근
   - LRU 리스트에서 최신 위치로 이동

**페이지 교체 정책 - LRU (Least Recently Used) 알고리즘:**
- 가장 오래 사용되지 않은 페이지를 먼저 제거
- 새로 로드된 페이지는 리스트 맨 앞에 배치
- 자주 사용되는 페이지는 리스트 맨 뒤에 유지
```text
LRU 리스트 구조:
[MRU] ←→ [Page1] ←→ [Page2] ←→ [Page3] ←→ [LRU]
  ↑                                        ↑
최근 사용                              오래된 사용
```

**메모리 접근 vs 디스크 접근**
```text
성능 비교:
메모리 접근: 100-1000ns (나노초)
디스크 접근: 10,000-100,000ns (마이크로초)

성능 차이: 메모리가 디스크보다 100-1000배 빠름
```


## 4. B-Tree 인덱스의 구조

> 인덱스는 페이지 단위로 저장되며, 인덱스 키를 바탕으로 항상 정렬된 상태를 유지한다. 
> 정렬된 인덱스 키를 따라서 리프 노드에 도달하면 (인덱스 키, PK) 쌍으로 저장되어 있다. 예를 들어 다음과 같이 설계된 테이블이 있다고 하자.


