---
title: "OCR Pipeline System"
date: ""
excerpt: "문서 이미지에서 텍스트를 추출하는 자동화된 OCR 파이프라인"
category: "Career"
tags: ["Python", "OCR", "Computer Vision", "Docker", "gRPC"]
---

- 기간 : 2024.07 ~ 2024.10 (4개월)
- 역할 : 시스템 기획부터 구현까지 모든 과정

## 프로젝트 개요

병원 검사 결과 이미지에서 실시간으로 검사 결과 데이터를 추출해 데이터베이스에 적재하는 OCR 파이프라인 시스템을 설계하고 구현했습니다. 환자의 검사 결과를 바탕으로 "시력 교정 수술 추천 서비스"나 "렌즈 사이즈 추천 서비스"를 운영하고 있었기 때문에, 안정적인 파이프라인을 구축해야만 안정적인 서비스를 운영할 수 있는 상황이었습니다.

<figure>
<img src="/post/Portfolio/OCR_pipeline.png" alt="OCR Pipeline" width="100%" />
<figcaption>그림1. OCR Pipeline 구조</figcaption>
</figure>

제가 구성한 파이프라인 구조는 그림1과 같습니다. 6가지 종류, 총 40~50대의 검사장비에서 검사를 진행하고 이를 실시간으로 OCR하고 추출된 데이터를 DB에 적재하게 됩니다.

### 전체 과정 요약

1. **레거시 코드 분석 및 문제점 파악** - 절차지향적으로 작성된 코드를 분석하고, 에러의 원인과 범위가 불명확한 구조적 문제를 식별했습니다.

2. **객체지향적 코드 구조로 재설계** - 기능과 역할을 명확히 구분하여 유지보수성과 확장성을 확보했고, 에러 추적이 쉬운 구조로 개선했습니다.

3. **비동기 처리 구조 도입** - Client-Server 구조를 재정의하여 OCR 처리 지연이 사용자 경험에 영향을 주지 않도록 개선했고, 평균 응답 속도를 5초에서 1초로 단축했습니다.

4. **테스트 및 타입 검증 체계 구축** - pytest 기반 unit test와 mypy를 활용한 타입 검증을 CI 과정에 통합하여 런타임 에러를 사전에 방지했습니다.

5. **OCR 정확도 개선** - 문제의 특성을 분석해 Text Detection 단계를 사전 정의하고, Text Recognition에 특화된 TrOCR 모델을 도입했습니다. 전처리 고도화와 후처리 개선을 통해 목표 정확도를 달성했습니다.

### 주요 성과

- **정확도 99%, 에러율 1% 미만의 안정적인 OCR 파이프라인 구축**
  - 기능과 역할이 명확하게 구분된 객체지향적인 코드 구조
  - 문제 이유와 범위가 명확하게 보이는 에러 로그
  - 지속적인 모니터링 시스템
  - 비동기 구조 적용으로 평균 응답 속도 5초 → 1초로 단축
  - pytest 기반 유닛 테스트와 mypy를 통한 타입 검증으로 런타임 에러 사전 방지

- **비즈니스 임팩트**
  - 안정적인 데이터 수집 기반을 구축하여 서비스 개발 및 운영의 안정성 확보
  - 검사 결과의 높은 정확도 보장으로 의료 서비스의 신뢰성 향상

### 핵심 배움

객체지향적 코드 구조의 필요성과 이를 통해 얻을 수 있는 유지보수성, 확장성, 안정성의 이점을 직접 체감했습니다. 특히 기능과 역할이 명확하게 구분된 코드는 디버깅과 추가 개발 작업의 복잡도를 크게 줄여주었고, 비동기 처리와 같은 최적화 포인트를 식별하는 데에도 도움이 되었습니다. 또한 pytest와 mypy를 활용한 사전 검증 체계는 단순히 에러를 방지하는 것을 넘어 코드 품질과 서비스 안정성을 보장하는 핵심 요소임을 깨달았습니다.

---

## 상세 과정

### 1. 레거시 코드 분석 및 문제점 파악

처음 프로젝트를 시작할 때의 상황은 전임자가 프로젝트를 진행하다가 중간에 떠난 상황이었습니다. 알 수 없는 에러로그가 쌓이고 있었고, OCR 모델의 정확도는 알 수 없었습니다. 어떤 문제를 해결하려고 해도 어디서 발생한 에러인지, 그 범위는 어디까지인지 알 수 없었습니다.

코드 구조에는 심각한 문제가 있었습니다. 모든 기능이 하나의 .py 파일에 절차지향적으로 뒤섞여 있어 기본적인 디자인 패턴이나 역할별 모듈화가 전혀 이루어지지 않았습니다. 이로 인해 코드의 가독성과 유지보수성이 크게 저하되었고, 에러 발생 시 원인 추적조차 쉽지 않았습니다. 또한 테스트 체계가 전혀 마련되어 있지 않아 런타임 에러를 사전에 방지할 수 있는 장치가 부족한 상태였습니다.

목표를 달성하기 위해서는 코드 구조를 개선하며 에러를 잡아나가야 했고, OCR 모델을 개선해야 했습니다.

### 2. 객체지향적 코드 구조로 재설계

무자비하게 쌓인 코드들을 보면서, 머리로 이해했던 1기능 1함수 원칙이나 디자인 패턴 등 코드를 잘 짜기 위한 방법들을 마음으로 이해할 수 있었습니다. 여러 기능이 하나의 함수에 작성되어있고, 타입힌트도 전혀 작성되어있지 않은 코드를 이해하고 디버깅하는 과정은 굉장히 어려웠습니다.

하지만 이런 코드를 이해하고 고쳐나가는 과정은 코드를 작성하는 능력을 키우는데 굉장히 큰 도움이 됐습니다. 이해하기 쉽고 디버깅이 쉬운 코드를 작성하기 위한 나름의 규칙들을 세울 수 있었습니다.

1. 함수에는 꼭 하나의 기능만, 객체에는 하나의 역할만 부여하기
2. 객체 지향의 꽃은 추상화, 입력과 출력만 신경쓸 수 있도록

이를 고려해 코드를 작성했고 문제를 하나씩 고쳐나갈 수 있었습니다. 에러의 범위와 원인을 파악하기 쉬워졌고, 전체 문제를 작은 문제들로 쪼갤 수 있었습니다.

### 3. 비동기 처리 구조 도입으로 속도 최적화

<figure>
<img src="/post/Portfolio/OCR_server_threadpool.png" alt="OCR Server 구조" width="80%" />
<figcaption>그림2. OCR Server 구조</figcaption>
</figure>

Client와 Server에서 실행되는 로직은 그림2와 같습니다. 처음 프로젝트를 인수인계 받을 때 동시에 여러 이미지를 처리하더라도 OCR 속도가 1초 미만이어야 한다고 했습니다. 그 이유는 Client 프로그램에서 Server로부터 응답이 늦게 오면, 그 다음에 진행되는 작업도 늦어지게 되고, 이는 고객에게 불편함을 주기 때문입니다.

Client에서 OCR 성공 여부를 확인할 필요가 있나? 에 대한 의문에서 시작했습니다. 이미지 송수신 여부만 확인하면 되기 때문에 주고 받을 성공여부에 대한 의미를 재정의했습니다. 그리고 Server에서의 역할을 구분했고, **OCR 과정이 속도가 오래걸리더라도 Client에는 영향을 미치지 않는 구조**로 재정의할 수 있었습니다.

### 4. 테스트 및 타입 검증 체계 구축

안정적인 파이프라인을 운영하기 위해 런타임 에러를 줄일 수 있는 방법에 대해 고민했습니다.

런타임 에러를 줄이기 위해 사용한 방법은, pytest를 통한 unit test와 mypy를 이용한 타입 검증입니다. 작게 쪼개놓은 기능이나 역할들이 잘 수행되는지 unit test를 통해 미리 확인하고, 주고 받는 값들의 타입들이 맞는지 미리 확인하는 작업을 CI 과정에서 진행했습니다.

이를 통해 어떤 기능을 추가하거나 수정했을 때 발생할 수 있는 런타임 에러들을 미리 검증하고 사전에 파악할 수 있었습니다.

### 5. OCR 정확도 개선

<figure>
<img src="/post/Portfolio/OCR_tritonserver.png" alt="OCR Model" width="50%" />
<figcaption>그림3. OCR Model</figcaption>
</figure>

안정적인 파이프라인이 어느정도 완성된 다음에는 99% 이상의 OCR 정확도를 어떻게 달성할 수 있을지에 대한 고민을 했습니다.

도메인 특성상 정확도가 특히 중요했으며, 목표는 99% 이상의 정확도 달성이었습니다. 그러나 초기에는 평가용 데이터셋이 부재하여 기존 모델의 성능을 객관적으로 확인할 수 없었습니다. 실제 검사 이미지 약 200건으로 테스트 데이터셋을 구축한 뒤 평가해본 결과, 기존 모델은 목표 성능에 미치지 못했습니다.

또한 직접 모델을 새로 개발할 수 없는 상황이었기 때문에, 제한된 조건 속에서 오픈소스 모델을 활용하여 목표 정확도를 달성해야 했습니다. 이를 위해 문제의 특징을 분석했습니다.

OCR은 크게 2단계로 구분됩니다. 위치를 찾는 Text Detection과 텍스트를 인식하는 Text Recognition입니다. 이미지가 고정된 형식이라는 특성을 활용해 Text Detection 단계를 사전에 정의하여 별도의 모델이 필요하지 않도록 했습니다. 따라서 OCR 파이프라인에서는 Text Recognition 단계에만 특화 모델을 적용하면 되었고, 이를 통해 목표 정확도 달성에 집중할 수 있었습니다.

여러 모델을 찾던 중 TrOCR이라는 오픈소스 모델을 발견했고, 이 모델이 개발된 동기가 Text Detection은 추후로 미루고 Text Recognition에 특화된 모델을 먼저 만들겠다는 것이어서 우리 상황에 적합했습니다.

이후 전처리 고도화와 후처리 개선을 반복 실험으로 검증하여 최종 성능을 끌어올렸습니다. 이미지 전처리와 결과 후처리 작업을 지속적으로 개선한 결과, 200건으로 구성한 테스트 셋에서 99% 이상, 거의 100%에 가까운 정확도를 확인할 수 있었습니다.

모델 배포는 온프레미스로 진행했고, TritonServer를 사용했습니다. TritonServer를 선택한 주요 이유는 동적 배치 처리와 동시성 관리를 쉽게 구현할 수 있고, 이를 통해 처리량을 달성할 수 있기 때문입니다.