---
title: "Index에 대한 정리"
date: "2025-08-14"
excerpt: "Index가 뭐고, 어떤 원리로 동작하는지 자세히 정리"
category: "Data Engineering"
tags: ["DB", "Index"]
---

참고자료
- 1: [블로그 - Database 인덱스(index)란?](https://mangkyu.tistory.com/96)

위에서는 인덱스에 대해 간단히 핵심만 다루고 있지만 PK(기본키, Primary Key)와 인덱스(Index)에 대해서 자세히 알고 있는 것은 굉장히 중요합니다. PK(기본키, Primary Key)와 인덱스(Index)에 대한 자세한 내용은 아래 포스팅을 참고해주세요! 굉장히 중요한 부분인만큼 한번 쯤은 읽어두시는 것을 추천드립니다!


# 1. What is Index?

> 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. (참고 1)

<figure>
<img src="/post/DataEngineering/index.png" alt="What is Index" />
<figcaption>그림1. Index 설명</figcaption>
</figure>

## 인덱스가 필요한 이유

### **테이블 스캔 vs 인덱스 스캔**

#### **테이블 스캔 (Table Scan)**
```
테이블 스캔의 문제점:
- 모든 행을 순차적으로 검사
- 데이터가 많을수록 검색 시간이 선형적으로 증가
- 예: 100만 건 테이블에서 특정 값을 찾을 때
  → 최악의 경우 100만 건을 모두 검사해야 함
  → 평균적으로 50만 건 검사 필요
```

#### **인덱스 스캔 (Index Scan)**
```
인덱스 스캔의 장점:
- 정렬된 인덱스 구조를 통해 빠른 검색
- B-tree 구조로 O(log n) 시간 복잡도
- 예: 100만 건 테이블에서 특정 값을 찾을 때
  → B-tree 높이만큼만 검사 (보통 3-4회)
  → 100만 건 → 20회 이하의 검사로 단축
```

### **인덱스의 장단점**

#### **장점**
- **검색 성능 향상**: 특정 조건의 데이터를 빠르게 찾을 수 있음
- **정렬 성능 향상**: ORDER BY 절의 성능 개선
- **조인 성능 향상**: 테이블 간 연결 시 인덱스 활용
- **고유성 보장**: UNIQUE 인덱스로 데이터 무결성 보장

#### **단점**
- **저장 공간 증가**: 인덱스 데이터를 위한 추가 저장 공간 필요
- **쓰기 성능 저하**: INSERT, UPDATE, DELETE 시 인덱스도 함께 수정
- **유지보수 오버헤드**: 데이터 변경 시 인덱스 재구성 필요
- **복잡성 증가**: 인덱스 설계와 관리의 복잡성

### **인덱스 사용 시나리오**

#### **인덱스가 효과적인 경우**
```
1. WHERE 절에서 자주 사용되는 컬럼
   - 예: user_id, email, created_date

2. JOIN 조건으로 사용되는 컬럼
   - 예: 외래키, 자주 조인되는 컬럼

3. ORDER BY, GROUP BY에서 사용되는 컬럼
   - 예: 정렬이나 그룹화 기준이 되는 컬럼

4. 고유한 값을 가진 컬럼
   - 예: 주민등록번호, 이메일 주소

5. 범위 검색이 자주 발생하는 컬럼
   - 예: 날짜, 나이, 가격 범위
```

#### **인덱스가 비효과적인 경우**
```
1. 데이터가 적은 테이블 (수백 건 이하)
   - 테이블 스캔이 더 빠를 수 있음

2. NULL 값이 많은 컬럼
   - 인덱스 효율성이 떨어짐

3. 자주 변경되는 컬럼
   - 인덱스 유지 비용이 높음

4. 데이터 분포가 균등하지 않은 컬럼
   - 예: 성별 (남/여만 있는 경우)

5. 텍스트가 긴 컬럼
   - 인덱스 크기가 커지고 효율성 저하
```

### **인덱스의 기본 원리**

#### **책의 목차와 같은 개념**
```
책에서 특정 내용을 찾는 방법:
1. 목차(인덱스)를 보고 해당 페이지 번호 확인
2. 해당 페이지로 바로 이동
3. 페이지 내에서 세부 내용 검색

테이블에서 특정 데이터를 찾는 방법:
1. 인덱스를 보고 해당 데이터의 위치 확인
2. 해당 위치로 바로 이동
3. 정확한 데이터 추출
```

#### **인덱스의 핵심 아이디어**
- **정렬된 구조**: 데이터를 미리 정렬하여 빠른 검색 가능
- **포인터 활용**: 실제 데이터 위치를 가리키는 포인터 저장
- **계층적 구조**: B-tree 등을 통한 효율적인 검색 경로 제공
- **선택적 접근**: 필요한 데이터만 정확하게 접근


# 2. Index data structure

## Hash Table 

> 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색 (시간복잡도 O(1)) 이 필요할 때 유용하다

<figure>
<img src="/post/DataEngineering/hash_table.png" alt="What is Hash Table" />
<figcaption>그림2. Hash Table 설명</figcaption>
</figure>

> 하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문이다. 
> 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

### **Hash Table의 제한적 사용 이유**

#### **해시 함수의 특성**
```
해시 함수의 결정적 특성:
- 입력값이 1이라도 달라지면 완전히 다른 해시값 생성
- 예시:
  "user123" → 해시 함수 → 8472
  "user124" → 해시 함수 → 1956
  "user125" → 해시 함수 → 3921

이 특성의 문제점:
- 연속된 값들이 전혀 다른 해시값을 가짐
- 순서나 크기 관계가 해시값에 반영되지 않음
- 범위 검색이나 정렬이 불가능
```

#### **데이터베이스 검색 패턴과의 불일치**
```
일반적인 데이터베이스 검색:
1. 정확한 값 검색: WHERE user_id = 'user123' ✓ (Hash Table 적합)
2. 범위 검색: WHERE age BETWEEN 20 AND 30 ✗ (Hash Table 부적합)
3. 정렬: ORDER BY created_date ✗ (Hash Table 부적합)
4. 부분 검색: WHERE name LIKE 'John%' ✗ (Hash Table 부적합)
5. 최대/최소값: WHERE price > 1000 ✗ (Hash Table 부적합)

Hash Table이 지원하는 검색:
- 등호(=) 연산만 지원
- 정확한 키 값으로의 직접 접근
- 순서나 관계 정보 없음
```

#### **실제 사용 사례의 제한**
```
Hash Table이 효과적인 경우:
- 사용자 로그인: WHERE email = 'user@example.com'
- 세션 조회: WHERE session_id = 'abc123'
- 캐시 조회: WHERE cache_key = 'user_profile_123'

Hash Table이 비효과적인 경우:
- 나이대별 사용자: WHERE age BETWEEN 20 AND 30
- 가격대별 상품: WHERE price > 1000 AND price < 5000
- 날짜별 주문: WHERE order_date >= '2024-01-01'
- 이름순 정렬: ORDER BY name ASC
```

### **B-tree vs Hash Table의 검색 능력 비교**

#### **등호 검색 (=)**
```
Hash Table:
- 성능: O(1) - 해시값 계산 후 직접 접근
- 예시: WHERE user_id = 'user123'
- 결과: 매우 빠름

B-tree:
- 성능: O(log n) - 트리 탐색 필요
- 예시: WHERE user_id = 'user123'
- 결과: 빠름 (하지만 Hash Table보다는 느림)
```

#### **범위 검색 (>, <, BETWEEN)**
```
Hash Table:
- 성능: 지원하지 않음
- 예시: WHERE age BETWEEN 20 AND 30
- 결과: 불가능

B-tree:
- 성능: O(log n + k) - k는 결과 개수
- 예시: WHERE age BETWEEN 20 AND 30
- 결과: 효율적 (순서대로 접근 가능)
```

#### **정렬 (ORDER BY)**
```
Hash Table:
- 성능: 지원하지 않음
- 예시: ORDER BY created_date DESC
- 결과: 불가능

B-tree:
- 성능: O(n log n) - 정렬된 순서로 접근
- 예시: ORDER BY created_date DESC
- 결과: 효율적 (이미 정렬된 구조)
```

### **Hash Table의 적절한 활용 방안**

#### **하이브리드 접근**
```
최적의 인덱스 전략:
1. 자주 사용되는 정확한 값 검색: Hash Index
   - 예: 사용자 ID, 이메일, 세션 ID

2. 범위 검색이나 정렬이 필요한 경우: B-tree Index
   - 예: 날짜, 나이, 가격, 이름

3. 복합 인덱스: B-tree 활용
   - 예: (category, price, created_date)
```

#### **메모리 기반 시스템에서의 활용**
```
Redis, Memcached 등에서 Hash Table 활용:
- 빠른 키-값 조회
- 세션 정보 저장
- 캐시 데이터 관리
- 실시간 데이터 처리

장점:
- 메모리 접근으로 극도로 빠른 속도
- 단순한 구조로 높은 처리량
- 확장 가능한 분산 시스템
```

### **결론**

Hash Table은 데이터베이스 인덱스에서 제한적으로 사용되는 이유가 명확합니다:

1. **등호 연산에만 특화**: 정확한 값 검색만 가능
2. **순서 정보 부재**: 범위 검색이나 정렬 불가
3. **해시 함수의 특성**: 연속된 값들이 전혀 다른 해시값 생성
4. **실용성 부족**: 대부분의 데이터베이스 검색 패턴과 맞지 않음

따라서 Hash Table은 특정 용도(빠른 키-값 조회, 메모리 기반 시스템)에만 사용하고, 일반적인 데이터베이스 인덱스로는 B-tree 구조가 훨씬 더 적합합니다.

### **Hash Table의 작동 원리**

#### **해시 함수 (Hash Function)**
```
해시 함수의 역할:
- 입력된 키를 고정된 크기의 해시값으로 변환
- 예: "user123" → 해시 함수 → 8472
- 동일한 키는 항상 동일한 해시값 생성
- 서로 다른 키가 같은 해시값을 가질 수 있음 (해시 충돌)

해시 함수의 특징:
- 결정적 (Deterministic): 같은 입력에 대해 항상 같은 출력
- 균등 분포 (Uniform Distribution): 해시값이 균등하게 분포
- 빠른 계산: O(1) 시간에 해시값 계산
```

#### **해시 충돌 (Hash Collision)**
```
해시 충돌이란:
- 서로 다른 키가 같은 해시값을 가지는 경우
- 예: "user123" → 8472, "admin456" → 8472

해결 방법:
1. 체이닝 (Chaining): 같은 해시값에 연결 리스트 사용
2. 개방 주소법 (Open Addressing): 다른 빈 슬롯 찾기
3. 이중 해싱 (Double Hashing): 두 번째 해시 함수 사용
```

### **Hash Table의 성능 특성**

#### **시간 복잡도**
```
검색 (Search):
- 평균: O(1) - 해시값 계산 후 직접 접근
- 최악: O(n) - 해시 충돌이 많을 경우

삽입 (Insert):
- 평균: O(1) - 해시값 계산 후 직접 저장
- 최악: O(n) - 해시 충돌 해결 과정

삭제 (Delete):
- 평균: O(1) - 해시값 계산 후 직접 제거
- 최악: O(n) - 해시 충돌 해결 과정
```

#### **공간 복잡도**
```
저장 공간:
- 기본: O(n) - 데이터 개수만큼 공간 필요
- 해시 충돌 해결: 추가 공간 필요
- 체이닝: 연결 리스트 노드 공간
- 개방 주소법: 빈 슬롯을 위한 여유 공간
```

### **Hash Table의 장단점**

#### **장점**
- **빠른 검색**: 평균 O(1) 시간에 데이터 접근
- **빠른 삽입/삭제**: 해시값 계산 후 직접 조작
- **메모리 효율성**: 데이터 크기에 비례하는 공간 사용
- **단순한 구조**: 구현이 비교적 간단

#### **단점**
- **해시 충돌**: 성능 저하의 주요 원인
- **순차 접근 비효율**: 범위 검색이나 정렬에 부적합
- **메모리 사용량**: 해시 충돌 해결을 위한 추가 공간
- **해시 함수 의존성**: 좋은 해시 함수 선택이 중요

### **Hash Table의 실제 구현**

#### **체이닝 방식**
```
구조:
Bucket[0]: [Key1, Value1] → [Key2, Value2] → null
Bucket[1]: [Key3, Value3] → null
Bucket[2]: null
...

장점:
- 구현이 간단
- 해시 충돌에 강함
- 동적 확장 가능

단점:
- 추가 메모리 사용
- 캐시 지역성 떨어짐
```

#### **개방 주소법**
```
구조:
Bucket[0]: [Key1, Value1]
Bucket[1]: [Key2, Value2] (충돌로 인한 이동)
Bucket[2]: [Key3, Value3] (충돌로 인한 이동)

장점:
- 메모리 효율성
- 캐시 지역성 좋음
- 추가 메모리 사용 최소

단점:
- 구현이 복잡
- 삭제 시 처리 복잡
- 클러스터링 문제
```

### **Hash Table의 인덱스 활용**

#### **적합한 사용 사례**
```
1. 정확한 값 검색 (Point Query):
   - 예: SELECT * FROM users WHERE user_id = 'user123'
   - 해시값으로 직접 접근하여 O(1) 성능

2. 고유 키 검색:
   - 예: 사용자 ID, 이메일 주소
   - 중복이 없는 고유한 값

3. 메모리 기반 인덱스:
   - Redis, Memcached 등
   - 빠른 응답 시간이 중요한 경우
```

#### **부적합한 사용 사례**
```
1. 범위 검색 (Range Query):
   - 예: SELECT * FROM users WHERE age BETWEEN 20 AND 30
   - 해시값은 순서가 없어 범위 검색 불가

2. 정렬이 필요한 경우:
   - 예: ORDER BY created_date
   - 해시값은 정렬 순서와 무관

3. 부분 문자열 검색:
   - 예: LIKE '%keyword%'
   - 해시값은 패턴 매칭에 부적합
```

### **Hash Table vs B-tree 비교**

#### **성능 비교**
```
검색 성능:
- Hash Table: 평균 O(1), 최악 O(n)
- B-tree: 항상 O(log n)

범위 검색:
- Hash Table: 지원하지 않음
- B-tree: O(log n + k) (k는 결과 개수)

정렬:
- Hash Table: 지원하지 않음
- B-tree: 순서대로 접근 가능
```

#### **메모리 사용량**
```
공간 효율성:
- Hash Table: O(n) + 충돌 해결 공간
- B-tree: O(n) + 노드 오버헤드

확장성:
- Hash Table: 재해싱 필요
- B-tree: 점진적 확장 가능
```


## B+Tree

<figure>
<img src="/post/DataEngineering/InnoDB-B-Tree-Structure.png" alt="InnoDB의 B+Tree 구조" />
<figcaption>그림3. InnoDB의 B+Tree 구조</figcaption>
</figure>


## B+Tree의 개념과 특징

### **B+Tree란?**
B+Tree는 B-Tree를 개선하여 데이터베이스 인덱스에 최적화된 자료구조입니다. 1970년대에 B-Tree의 단점을 보완하여 개발되었습니다.

### **B+Tree의 핵심 구조**

#### **데이터 저장 방식**
```
B+Tree의 노드 구조:
Internal 노드: 키(Key)와 포인터만 저장
- [Key1, Pointer1, Key2, Pointer2, ...]
- 실제 데이터는 저장하지 않음 (검색 경로 제공)

Leaf 노드: 키(Key)와 데이터(Value) 저장
- [Key1, Value1, Key2, Value2, ...]
- 실제 데이터가 저장되는 곳
- 모든 Leaf 노드는 논리적 순서대로 연결되어 범위/순차 접근에 유리
```

#### **메모리/페이지 관점의 구조적 이점**
```
- Internal 노드가 작아 한 페이지에 더 많은 키를 적재 → 트리 높이 감소
- Leaf 노드는 데이터 밀도가 높아 I/O 효율 증가
- 페이지 단위(prefetch)로 읽을 때 순차 접근 이점 큼
```

### **B+Tree의 검색 과정**

#### **정확한 값 검색 (Point Query)**
```
1) Root → Internal 노드들을 따라 하향 탐색
2) 목적 키 범위의 포인터를 선택하며 Leaf 도달
3) Leaf에서 키를 찾아 데이터 반환

시간 복잡도: O(log n)
```

#### **범위 검색 (Range Query)**
```
1) 시작 키를 찾기 위해 트리 탐색 (O(log n))
2) 해당 Leaf에서 시작하여 다음 Leaf로 순차 접근
3) 끝 조건까지 결과 수집 (O(k))

총 시간 복잡도: O(log n + k)
```

### **B+Tree의 장단점**

#### **장점**
```
- 범위/순차 접근 최적화 (Leaf 간 논리적 연결)
- Internal 노드가 작아 트리 높이가 낮음 → I/O 감소
- 예측 가능한 검색 성능: O(log n)
```

#### **단점**
```
- 항상 Leaf까지 내려가야 데이터 접근 가능
- 노드 분할/병합 시 연결 유지 관리 비용 존재
```

### **B+Tree의 실제 활용**
```
MySQL InnoDB:
- 클러스터형 인덱스(Primary Key)와 보조 인덱스(Secondary) 모두 B+Tree 기반

PostgreSQL/Oracle:
- 기본 범용 인덱스로 B+Tree 채택, 복합 인덱스/범위 쿼리에 최적
```

### **B+Tree의 성능 특성 요약**
```
정확한 값 검색: O(log n)
범위 검색: O(log n + k)
순차 접근: 첫 원소 O(log n) + 후속 O(1) (페이지 순차 접근)
정렬: 인덱스 순서 접근으로 추가 정렬 최소화
```

### **결론**
B+Tree는 Internal/Leaf 분리와 Leaf 간 논리적 연결로 범위/순차 접근에 매우 강하며, 낮은 트리 높이를 통해 일관된 O(log n) 성능을 제공하기 때문에 현대 데이터베이스의 표준 인덱스 구조로 널리 쓰입니다.
