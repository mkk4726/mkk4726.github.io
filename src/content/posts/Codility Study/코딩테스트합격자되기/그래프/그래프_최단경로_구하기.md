---
title: "그래프 최단 경로 구하기"
date: "2025-08-02"
excerpt: "그래프 최단 경로 구하기"
category: "Codility Study"
tags: ["코딩 테스트 합격자 되기", "Codility Study", "그래프", "알고리즘"]
---

> 최단 경로 (shortest path)는 그래프의 종류에 따라 그 진의가 다르게 해석될 수도 있는 주제입니다.

가중치의 여부. 


| 알고리즘 | 목적 | 장단점 및 특징 | 시간 복잡도 |
|---------|------|----------------|-------------|
| 다익스트라 알고리즘 | 출발 노드로부터 도착 노드들까지의 최단 경로 찾기 | 음의 가중치를 가지는 그래프에서 최단 경로를 구할 수 없음 (그리디 방식) | O(V^2), 우선순위 큐로 개선하면 O(E* logV) |
| 벨만-포드 알고리즘 | 출발 노드로부터 도착 노드들까지의 최단 경로 찾기 | 음의 가중치를 가지는 그래프에서 최단 경로를 구할 수 있고, 음의 순환도 감지할 수 있음 | O(V*E) |



# 다익스트라(dijkstra) 알고리즘
---

모든 가중치가 양수일 때.

> 다익스트라 알고리즘의 목적은 그래프 내에서 특정 노드를 기준으로 각 노드까지 최단 경로 또는 최단 경로의 길이를 찾는 것에 있습니다.
> 다익스트라 알고리즘의 핵심은 현재까지 발견한 가장 적은 비용으로 갈 수 있는 노드를 경유해서, 각 노드까지 최단 경로를 갱신하는 작업을 반복하는 것입니다.

1. 시작 노드에서 각 노드까지 거리를 초기화
2. 현재 가장 적은 비용으로 갈 수 있는 노드 선택 (각 노드는 한 번씩만 선택)
3. 2에서 선택한 노드의 주변 노드 거리를 갱신


알고리즘 동작 순서

1. 시작 노드를 설정하고 시작 노드로부터 특정 노드까지의 최소 비용을 저장할 공간과 직전 노드를 저장할 공간을 마련합니다.
    1-1. 최소 비용을 저장할 공간은 모두 매우 큰 값으로 초기화합니다.
    1-2. 시작 노드의 최소비용은 0, 직전 노드는 자신으로 합니다.
2. 현재까지 구한 각 노드까지 최소 비용을 기준으로 지금까지 선택하지 않은 노드 중 최소 비용이 가장 적은 노드를 선택합니다.
    2-1. 해당 노드를 거쳐서 각 노드까지  가는 최소 비용과 현재까지 구한 최소 비용을 비교하여 작은 값을 각 노드의 최소 비용으로 갱신합니다.
    2-2. 이때 직전 노드도 같이 갱신합니다.
3. 노드 개수에서 1을 뺀 만큼 반복합니다.


# 벨만-포드(bellman-ford) 알고리즘
---

> 벨만-포드 알고리즘은 매 단계마다 모든 간선의 가중치를 다시 확인하여 최소 비용을 갱신하므로 음의 가중치를 가지는 그래프에서도 최단 경로를 구할 수 있습니다.


알고리즘 동작순서

1. 시작노드를 설정한 다음 시작 노드의 최소 비용은 0, 나머지 노드는 INF로 초기화.
2. 노드 개수 -1 만큼 다음 연산은 반복
    2-1. 시작 노드에서 갈 수 있는 각 노드에 대하여 전체 노드 각각을 거쳐갈 때 현재까지 구한 최소 비용보다 더 적은 최소 비용이 있는지 확인하여 갱신.
3. 과정2를 마지막으로 한번 더 수행하여 갱신되는 최소 비용이 있는지 확인. 있다면 음의 순환이 있음을 의미.

## 왜 정점개수 -1만큼 반복하는가? 매 연산마다 최단경로가 1개씩 확정되므로!

벨만-포드 알고리즘에서 정점 개수 - 1번만큼 반복하는 이유는 **최단 경로의 특성** 때문입니다.

### 핵심 원리
- **최단 경로는 최대 V-1개의 간선으로 구성됩니다**
- n개의 정점이 있을 때, 최단 경로는 최대 n-1개의 간선을 가질 수 있습니다
- 만약 n개 이상의 간선이 있다면, 그 경로에는 반드시 **순환(cycle)**이 포함되어 있습니다

### 예시로 이해하기
```
정점: A, B, C, D (4개)
가능한 최단 경로:
- A → B → C → D (3개 간선, 최대)
- A → B → D (2개 간선)
- A → D (1개 간선)
```

### 왜 V-1번이면 충분한가?
1. **1번째 반복**: 출발점에서 1개 간선으로 도달 가능한 모든 정점의 최단 거리 확정
2. **2번째 반복**: 출발점에서 2개 간선으로 도달 가능한 모든 정점의 최단 거리 확정
3. **...**
4. **(V-1)번째 반복**: 출발점에서 (V-1)개 간선으로 도달 가능한 모든 정점의 최단 거리 확정

이후 더 반복해도 새로운 최단 경로를 찾을 수 없습니다.

## 왜 한번 더 연산을 반복하는가? 음의 순환을 찾기 위해!

벨만-포드 알고리즘의 마지막 단계에서 한 번 더 반복하는 이유는 **음의 순환(negative cycle)을 감지**하기 위해서입니다.

### 음의 순환이란?
```
A → B → C → A (순환)
가중치: 2 → 3 → (-6) → 2
```
이 경우 A에서 시작해서 A로 돌아올 때마다 비용이 -1씩 감소합니다. 즉, 무한히 작아질 수 있습니다.

### 감지 방법
1. **V-1번 반복**: 정상적인 최단 경로 계산
2. **V번째 반복**: 한 번 더 반복하여 거리 값이 갱신되는지 확인
   - 만약 거리 값이 갱신된다면 → 음의 순환이 존재
   - 만약 거리 값이 갱신되지 않는다면 → 음의 순환이 없음

### 예시
```
정점: A, B, C
간선: A→B(2), B→C(3), C→A(-6)

V-1번 반복 후:
dist[A] = 0, dist[B] = 2, dist[C] = 5

V번째 반복 시:
dist[A] = 5 + (-6) = -1 (갱신됨!)
→ 음의 순환 존재!
```

### 왜 V번째에서 감지되는가?
- V-1번 반복으로 모든 정상적인 최단 경로를 찾았습니다
- V번째 반복에서 거리 값이 갱신된다면, 그것은 V개 이상의 간선을 사용하는 경로입니다
- V개 이상의 간선을 사용하는 경로는 반드시 순환을 포함합니다
- 그 순환이 음의 가중치를 가진다면, 거리 값이 계속 감소하게 됩니다



